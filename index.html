<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Color Palette Generator</title>
  <style>
    /* Reset and base styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      color: #333;
      background-color: #f5f5f5;
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      overflow-x: hidden;
    }

    /* Layout */
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem;
      position: relative;
      z-index: 10;
    }

    .app-container {
      background-color: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 1.5rem;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      margin-top: 2rem;
    }

    /* Typography */
    h1 {
      font-size: 2rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
      text-align: center;
      color: #333;
    }

    h2 {
      font-size: 1.5rem;
      font-weight: 600;
      margin-bottom: 1rem;
    }

    h3 {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 0.75rem;
    }

    p {
      margin-bottom: 1rem;
    }

    .subtitle {
      text-align: center;
      color: #666;
      margin-bottom: 2rem;
    }

    /* Buttons */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.5rem 1rem;
      border-radius: 0.375rem;
      font-weight: 500;
      font-size: 0.875rem;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 1px solid transparent;
      gap: 0.5rem;
    }

    .btn-primary {
      background-color: #1a1a1a;
      color: white;
    }

    .btn-primary:hover {
      background-color: #333;
    }

    .btn-outline {
      background-color: transparent;
      border-color: #ddd;
      color: #555;
    }

    .btn-outline:hover {
      background-color: #f5f5f5;
    }

    .btn-green {
      color: #22c55e;
      border-color: #22c55e;
    }

    .btn-green:hover {
      background-color: rgba(34, 197, 94, 0.1);
    }

    .btn-red {
      color: #ef4444;
      border-color: #ef4444;
    }

    .btn-red:hover {
      background-color: rgba(239, 68, 68, 0.1);
    }

    .btn-purple {
      background-color: #8b5cf6;
      color: white;
    }

    .btn-purple:hover {
      background-color: #7c3aed;
    }

    /* Dropdown */
    .dropdown {
      position: relative;
      display: inline-block;
    }

    .dropdown-arrow {
      margin-left: 4px;
      transition: transform 0.2s ease;
    }

    .dropdown.active .dropdown-arrow {
      transform: rotate(180deg);
    }

    .dropdown-content {
      display: none;
      position: absolute;
      background-color: white;
      min-width: 180px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
      border-radius: 0.375rem;
      z-index: 20;
      top: 100%;
      left: 0;
      margin-top: 0.5rem;
      overflow: hidden;
    }

    .dropdown.active .dropdown-content {
      display: block;
      animation: fadeIn 0.2s ease;
    }

    .dropdown-item {
      padding: 0.75rem 1rem;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background-color 0.2s ease;
    }

    .dropdown-item:hover {
      background-color: #f5f5f5;
    }

    .dropdown-item.active {
      background-color: #f0f0f0;
      font-weight: 600;
    }

    .format-example {
      font-family: monospace;
      font-size: 0.75rem;
      color: #666;
    }

    @media (max-width: 768px) {
      .dropdown-content {
        position: fixed;
        left: 50%;
        transform: translateX(-50%);
        width: 90%;
        max-width: 300px;
      }
    }

    /* Controls */
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      justify-content: center;
    }

    .select-container {
      width: 100%;
      max-width: 300px;
      margin: 1rem auto;
    }

    select {
      width: 100%;
      padding: 0.5rem;
      border-radius: 0.375rem;
      border: 1px solid #ddd;
      background-color: white;
      font-size: 0.875rem;
    }

    /* Color Palette */
    .color-palette {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1.5rem;
    }

    .color-card {
      border-radius: 0.5rem;
      overflow: hidden;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .color-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
    }

    .color-display {
      height: 150px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 1rem;
      cursor: pointer;
    }

    .color-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: white;
      padding: 0.75rem;
    }

    .color-info {
      font-family: monospace;
      font-size: 0.875rem;
      margin-top: auto;
    }

    .color-format-btn {
      font-size: 0.75rem;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      background-color: rgba(255, 255, 255, 0.2);
      cursor: pointer;
    }

    .color-format-btn:hover {
      background-color: rgba(255, 255, 255, 0.3);
    }

    .color-picker {
      width: 2rem;
      height: 2rem;
      border: none;
      border-radius: 0.25rem;
      cursor: pointer;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
    }

    .color-picker::-webkit-color-swatch-wrapper {
      padding: 0;
    }

    .color-picker::-webkit-color-swatch {
      border: none;
      border-radius: 0.25rem;
    }

    .color-picker::-moz-color-swatch {
      border: none;
      border-radius: 0.25rem;
    }

    /* Tabs */
    .tabs {
      margin-bottom: 1.5rem;
    }

    .tab-list {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .tab {
      padding: 0.5rem;
      text-align: center;
      border-radius: 0.375rem;
      cursor: pointer;
      background-color: #f5f5f5;
      transition: all 0.2s ease;
    }

    .tab.active {
      background-color: #333;
      color: white;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* AI Features */
    .advanced-features {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .feature-card {
      background-color: #f5f5f5;
      border-radius: 0.5rem;
      padding: 1rem;
    }

    .feature-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .feature-icon {
      color: #8b5cf6;
    }

    .slider-container {
      margin-bottom: 1rem;
    }

    .slider-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
    }

    .slider {
      width: 100%;
      height: 0.5rem;
      -webkit-appearance: none;
      appearance: none;
      background: #ddd;
      border-radius: 0.25rem;
      outline: none;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 1rem;
      height: 1rem;
      border-radius: 50%;
      background: #8b5cf6;
      cursor: pointer;
    }

    .slider::-moz-range-thumb {
      width: 1rem;
      height: 1rem;
      border-radius: 50%;
      background: #8b5cf6;
      cursor: pointer;
      border: none;
    }

    .slider-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      color: #666;
      margin-top: 0.25rem;
    }

    .preference-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .progress-container {
      margin-bottom: 0.5rem;
    }

    .progress-bar {
      height: 0.5rem;
      background-color: #ddd;
      border-radius: 0.25rem;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background-color: #8b5cf6;
      width: 0%;
      transition: width 0.3s ease;
    }

    /* Modal */
    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      padding: 1rem;
    }

    .modal-content {
      background-color: white;
      border-radius: 0.5rem;
      padding: 1.5rem;
      max-width: 500px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .close-btn {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1.25rem;
      color: #666;
    }

    .close-btn:hover {
      color: #333;
    }

    /* Color Info Modal */
    .color-preview {
      height: 100px;
      border-radius: 0.375rem;
      margin-bottom: 1rem;
    }

    .color-values {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
      margin-bottom: 1.5rem;
    }

    .color-value-box {
      background-color: #f5f5f5;
      padding: 0.5rem;
      border-radius: 0.375rem;
    }

    .color-value-label {
      font-size: 0.75rem;
      color: #666;
      margin-bottom: 0.25rem;
    }

    .color-value {
      font-family: monospace;
      font-size: 0.875rem;
    }

    .harmony-colors {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
    }

    .harmony-color {
      width: 2rem;
      height: 2rem;
      border-radius: 0.25rem;
      cursor: pointer;
    }

    .contrast-info {
      margin-bottom: 0.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .contrast-badge {
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.75rem;
    }

    .contrast-pass {
      background-color: #dcfce7;
      color: #166534;
    }

    .contrast-fail {
      background-color: #fee2e2;
      color: #b91c1c;
    }

    /* History Modal */
    .history-palette {
      cursor: pointer;
      margin-bottom: 1.5rem;
    }

    .history-colors {
      display: flex;
      height: 3rem;
      border-radius: 0.375rem;
      overflow: hidden;
      margin-bottom: 0.5rem;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    .history-color {
      flex: 1;
    }

    .history-info {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      color: #666;
    }

    /* Export Modal */
    .export-preview {
      display: flex;
      height: 3rem;
      border-radius: 0.375rem;
      overflow: hidden;
      margin-bottom: 1rem;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    .export-color {
      flex: 1;
    }

    .export-tabs {
      margin-bottom: 1rem;
    }

    .export-code {
      background-color: #f5f5f5;
      padding: 1rem;
      border-radius: 0.375rem;
      font-family: monospace;
      font-size: 0.875rem;
      white-space: pre-wrap;
      overflow-x: auto;
      margin-bottom: 1rem;
      max-height: 200px;
      overflow-y: auto;
    }

    .export-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
    }

    /* Import Modal */
    .import-input {
      width: 100%;
      padding: 0.75rem;
      border: 1px solid #ddd;
      border-radius: 0.375rem;
      font-family: monospace;
      font-size: 0.875rem;
      resize: vertical;
      min-height: 100px;
      margin-bottom: 1rem;
    }

    .import-examples {
      font-size: 0.75rem;
      color: #666;
      margin-bottom: 1.5rem;
    }

    .import-examples ul {
      padding-left: 1.5rem;
      margin-top: 0.5rem;
    }

    .error-message {
      background-color: #fee2e2;
      color: #b91c1c;
      padding: 0.75rem;
      border-radius: 0.375rem;
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    /* Canvas Background */
    #background-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }

    /* Toast Notifications */
    .toast-container {
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      z-index: 100;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .toast {
      background-color: white;
      border-radius: 0.375rem;
      padding: 0.75rem 1rem;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      display: flex;
      flex-direction: column;
      min-width: 250px;
      max-width: 350px;
      animation: slideIn 0.3s ease, fadeOut 0.5s ease 2.5s forwards;
    }

    .toast-title {
      font-weight: 600;
      margin-bottom: 0.25rem;
    }

    .toast-message {
      font-size: 0.875rem;
      color: #666;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes fadeOut {
      from {
        opacity: 1;
      }
      to {
        opacity: 0;
        transform: translateY(10px);
      }
    }

    /* Responsive Styles */
    /* Enhanced responsive styles */
    @media (max-width: 768px) {
      .color-palette {
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 0.75rem;
      }
      
      .color-display {
        height: 110px;
      }
      
      .controls {
        justify-content: center;
        flex-wrap: wrap;
      }
      
      .btn {
        padding: 0.375rem 0.75rem;
        font-size: 0.75rem;
      }
      
      .modal-content {
        width: 90%;
        max-width: 90%;
        margin: 0 auto;
      }
    }

    @media (max-width: 480px) {
      .color-palette {
        grid-template-columns: repeat(2, 1fr);
        gap: 0.5rem;
      }
      
      .color-display {
        height: 100px;
        padding: 0.75rem;
      }
      
      .color-info {
        font-size: 0.75rem;
      }
      
      .controls {
        gap: 0.375rem;
      }
      
      .btn {
        padding: 0.25rem 0.5rem;
        min-height: 36px;
      }
      
      .dropdown-content {
        max-width: 250px;
      }
    }

    /* Touch device optimizations */
    @media (hover: none) and (pointer: coarse) {
      .btn, 
      .dropdown-item,
      .color-info-btn,
      .copy-btn {
        min-height: 44px;
        min-width: 44px;
      }
      
      .dropdown-item {
        padding: 0.875rem 1rem;
      }
      
      input[type="color"] {
        width: 44px;
        height: 44px;
      }
      
      .color-controls {
        padding: 0.5rem;
      }
    }

    /* For browsers that don't support backdrop-filter */
    @supports not ((backdrop-filter: blur(10px)) or (-webkit-backdrop-filter: blur(10px))) {
      .app-container {
        background-color: rgba(255, 255, 255, 0.95);
      }

      .modal-backdrop {
        background-color: rgba(0, 0, 0, 0.7);
      }
    }

    /* Improved focus styles for accessibility */
    :focus-visible {
      outline: 2px solid #8b5cf6;
      outline-offset: 2px;
    }

    /* Hide focus outline for mouse users, but keep for keyboard */
    :focus:not(:focus-visible) {
      outline: none;
    }

    /* Icons */
    .icon {
      display: inline-block;
      width: 1em;
      height: 1em;
      stroke-width: 0;
      stroke: currentColor;
      fill: currentColor;
      vertical-align: middle;
    }

    /* Loading spinner */
    .spinner {
      border: 3px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top: 3px solid #8b5cf6;
      width: 1.5rem;
      height: 1.5rem;
      animation: spin 1s linear infinite;
      display: inline-block;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Utility classes */
    .hidden {
      display: none !important;
    }

    .flex {
      display: flex;
    }

    .items-center {
      align-items: center;
    }

    .justify-between {
      justify-content: space-between;
    }

    .gap-2 {
      gap: 0.5rem;
    }

    .mt-auto {
      margin-top: auto;
    }

    .w-full {
      width: 100%;
    }

    .text-purple {
      color: #8b5cf6;
    }

    .text-center {
      text-align: center;
    }

    .font-mono {
      font-family: monospace;
    }

    .text-sm {
      font-size: 0.875rem;
    }

    .text-xs {
      font-size: 0.75rem;
    }

    .font-bold {
      font-weight: 700;
    }

    .text-gray {
      color: #666;
    }

    .truncate {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Browser-specific styles */
    .is-safari input[type="color"] {
      padding: 0;
      border: none;
    }

    .is-firefox input[type="color"] {
      padding: 0;
      border: none;
    }

    .is-ios .color-controls {
      padding-bottom: env(safe-area-inset-bottom, 0.75rem);
    }

    .is-touch-device .btn,
    .is-touch-device .dropdown-item,
    .is-touch-device .color-info-btn,
    .is-touch-device .copy-btn {
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }

    .is-touch-device input,
    .is-touch-device select,
    .is-touch-device textarea {
      font-size: 16px; /* Prevents iOS zoom on focus */
    }
  </style>
</head>
<body>
  <canvas id="background-canvas"></canvas>

  <div class="container">
    <div class="app-container">
      <header>
        <h1>Color Palette Generator</h1>
        <p class="subtitle">Generate beautiful color palettes that learn from your preferences</p>
      </header>

      <div class="tabs">
        <div class="tab-list">
          <div class="tab active" data-tab="palette">Palette</div>
          <div class="tab" data-tab="advanced">Advanced Features</div>
        </div>

        <div class="tab-content active" id="palette-tab">
          <div class="controls">
            <button class="btn btn-primary" id="generate-btn">
              <svg class="icon" viewBox="0 0 24 24" width="16" height="16">
                <path d="M23 4v2h-3v3h-2V6h-3V4h3V1h2v3h3zm-8.5 7a4.5 4.5 0 100-9 4.5 4.5 0 000 9zM5.5 20a4.5 4.5 0 100-9 4.5 4.5 0 000 9zM16.5 20a4.5 4.5 0 100-9 4.5 4.5 0 000 9z"></path>
              </svg>
              <span class="btn-text">Generate New Palette</span>
            </button>

            <button class="btn btn-outline" id="history-btn">
              <svg class="icon" viewBox="0 0 24 24" width="16" height="16">
                <path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8zm1-8.5V7c0-.6-.4-1-1-1s-1 .4-1 1v5c0 .3.1.5.3.7l3.5 3.5c.4.4 1 .4 1.4 0 .4-.4.4-1 0-1.4L13 11.5z"></path>
              </svg>
              <span class="btn-text">View History</span>
            </button>

            <button class="btn btn-outline" id="format-btn">
              <svg class="icon" viewBox="0 0 24 24" width="16" height="16">
                <path d="M3 17v2h6v-2H3zM3 5v2h10V5H3zm10 16v-2h8v-2h-8v-2h-2v6h2zM7 9v2H3v2h4v2h2V9H7zm14 4v-2H11v2h10zm-6-4h2V7h4V5h-4V3h-2v6z"></path>
              </svg>
              <span class="btn-text">Format: <span id="current-format">HEX</span></span>
            </button>

            <button class="btn btn-outline btn-green" id="like-btn">
              <svg class="icon" viewBox="0 0 24 24" width="16" height="16">
                <path d="M14 9V5a3 3 0 00-3-3l-4 9v11h11.3a2 2 0 001.9-1.6l1.7-7a2 2 0 00-2-2.4H14zm-8 12h2V9H6v12z"></path>
              </svg>
              <span class="btn-text">Like</span>
            </button>

            <button class="btn btn-outline btn-red" id="dislike-btn">
              <svg class="icon" viewBox="0 0 24 24" width="16" height="16">
                <path d="M10 15v4a3 3 0 003 3l4-9V2H5.7a2 2 0 00-1.9 1.6l-1.7 7a2 2 0 002 2.4H10zm8-12h-2v12h2V3z"></path>
              </svg>
              <span class="btn-text">Dislike</span>
            </button>

            <button class="btn btn-outline" id="export-btn">
              <svg class="icon" viewBox="0 0 24 24" width="16" height="16">
                <path d="M5 16v2h14v-2H5zm0-8h4v6h6V8h4L12 1 5 8z"></path>
              </svg>
              <span class="btn-text">Export CSS</span>
            </button>

            <button class="btn btn-outline" id="import-btn">
              <svg class="icon" viewBox="0 0 24 24" width="16" height="16">
                <path d="M5 8v2h14V8H5zm0 8h4v-6h6v6h4L12 23 5 16z"></path>
              </svg>
              <span class="btn-text">Import</span>
            </button>
          </div>

          <div class="select-container">
            <select id="generation-mode">
              <option value="random">Random</option>
              <option value="smart">Smart Suggested</option>
              <option value="harmonious">Harmonious</option>
              <option value="analogous">Analogous</option>
              <option value="monochromatic">Monochromatic</option>
              <option value="complementary">Complementary</option>
              <option value="triadic">Triadic</option>
              <option value="tetradic">Tetradic</option>
            </select>
          </div>

          <div class="color-palette" id="color-palette">
            <!-- Color cards will be generated here -->
          </div>
        </div>

        <div class="tab-content" id="advanced-tab">
          <div class="advanced-features">
            <div class="feature-card">
              <div class="feature-header">
                <svg class="icon feature-icon" viewBox="0 0 24 24" width="20" height="20">
                  <path d="M21 11c0 5.5-4.5 10-10 10S1 16.5 1 11 5.5 1 11 1s10 4.5 10 10zM11 3c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zm1 13h-2v-6h2v6zm0-8h-2V6h2v2z"></path>
                </svg>
                <h3>Learning Engine</h3>
              </div>

              <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                  <p class="text-sm text-gray-600 mb-2">Total Samples Learned</p>
                  <div class="flex items-center gap-2">
                    <span class="text-2xl font-bold" id="total-samples">0</span>
                    <span class="text-xs text-gray-500">colors</span>
                  </div>
                </div>

                <div>
                  <p class="text-sm text-gray-600 mb-2">Algorithm Confidence</p>
                  <div class="flex items-center gap-2">
                    <div class="progress-bar">
                      <div class="progress-fill" id="confidence-bar" style="width: 0%"></div>
                    </div>
                    <span class="text-xs text-gray-500" id="confidence-value">0%</span>
                  </div>
                </div>
              </div>

              <div class="flex flex-wrap gap-2">
                <button class="btn btn-outline" id="train-algorithm-btn">
                  <svg class="icon" viewBox="0 0 24 24" width="16" height="16">
                    <path d="M12 16l4-4h-3V3h-2v9H8l4 4zm9-13h-6v2h6v16H3V5h6V3H3a2 2 0 00-2 2v16a2 2 0 002 2h18a2 2 0 002-2V5a2 2 0 002-2z"></path>
                  </svg>
                  <span class="btn-text">Train Algorithm</span>
                </button>

                <button class="btn btn-outline btn-red" id="reset-algorithm-btn">
                  <svg class="icon" viewBox="0 0 24 24" width="16" height="16">
                    <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path>
                  </svg>
                  Reset Algorithm
                </button>
              </div>
            </div>

            <div class="feature-card">
              <div class="feature-header">
                <svg class="icon feature-icon" viewBox="0 0 24 24" width="20" height="20">
                  <path d="M17.5 12a5.5 5.5 0 100-11 5.5 5.5 0 000 11zM5.5 23a5.5 5.5 0 100-11 5.5 5.5 0 000 11zM17.5 23a5.5 5.5 0 100-11 5.5 5.5 0 000 11z"></path>
                </svg>
                <h3>Smart Palette Generation</h3>
              </div>

              <div class="space-y-4">
                <div class="slider-container">
                  <div class="slider-header">
                    <label class="text-sm text-gray-600">Creativity Level</label>
                    <span class="text-sm font-medium" id="creativity-value">50%</span>
                  </div>
                  <input type="range" min="0" max="100" value="50" class="slider" id="creativity-slider">
                  <div class="slider-labels">
                    <span>Conservative</span>
                    <span>Experimental</span>
                  </div>
                </div>

                <div>
                  <label class="text-sm text-gray-600 block mb-2">Color Preference</label>
                  <div class="preference-buttons">
                    <button class="btn btn-outline active" data-preference="balanced">Balanced</button>
                    <button class="btn btn-outline" data-preference="warm">Warm</button>
                    <button class="btn btn-outline" data-preference="cool">Cool</button>
                    <button class="btn btn-outline" data-preference="vibrant">Vibrant</button>
                    <button class="btn btn-outline" data-preference="pastel">Pastel</button>
                    <button class="btn btn-outline" data-preference="dark">Dark</button>
                  </div>
                </div>

                <button class="btn btn-purple w-full" id="generate-smart-btn">
                  <svg class="icon" viewBox="0 0 24 24" width="16" height="16">
                    <path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7zm2.85 11.1l-.85.6V16h-4v-2.3l-.85-.6A4.997 4.997 0 017 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 1.63-.8 3.16-2.15 4.1z"></path>
                  </svg>
                  Generate Smart Palette
                </button>
              </div>
            </div>

            <div class="feature-card">
              <div class="feature-header">
                <svg class="icon feature-icon" viewBox="0 0 24 24" width="20" height="20">
                  <path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"></path>
                </svg>
                <h3>Color Analytics</h3>
              </div>

              <div class="space-y-3">
                <div>
                  <p class="text-sm text-gray-600 mb-1">Liked Colors</p>
                  <div class="progress-bar">
                    <div class="progress-fill" id="liked-colors-bar" style="width: 0%"></div>
                  </div>
                  <p class="text-xs text-gray-500 mt-1" id="liked-colors-count">0 colors liked</p>
                </div>

                <div>
                  <p class="text-sm text-gray-600 mb-1">Disliked Colors</p>
                  <div class="progress-bar">
                    <div class="progress-fill" id="disliked-colors-bar" style="width: 0%"></div>
                  </div>
                  <p class="text-xs text-gray-500 mt-1" id="disliked-colors-count">0 colors disliked</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Color Info Modal -->
  <div class="modal-backdrop hidden" id="color-info-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Color Details</h2>
        <button class="close-btn" id="close-color-info">&times;</button>
      </div>
      <div class="color-preview" id="color-preview"></div>
      <div class="flex justify-between items-center mb-4">
        <h3 id="color-name">Color Name</h3>
        <button class="btn btn-outline" id="copy-color-btn">
          <svg class="icon" viewBox="0 0 24 24" width="16" height="16">
            <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path>
          </svg>
          <span id="color-hex-value">#FFFFFF</span>
        </button>
      </div>

      <div class="space-y-4">
        <div>
          <h4 class="text-sm font-medium text-gray-700 mb-2">Color Values</h4>
          <div class="color-values">
            <div class="color-value-box">
              <p class="color-value-label">RGB</p>
              <p class="color-value" id="rgb-value">255, 255, 255</p>
            </div>
            <div class="color-value-box">
              <p class="color-value-label">HSL</p>
              <p class="color-value" id="hsl-value">0°, 0%, 100%</p>
            </div>
            <div class="color-value-box">
              <p class="color-value-label">CMYK</p>
              <p class="color-value" id="cmyk-value">0, 0, 0, 0</p>
            </div>
            <div class="color-value-box">
              <p class="color-value-label">HEX</p>
              <p class="color-value" id="hex-value">#FFFFFF</p>
            </div>
          </div>
        </div>

        <div>
          <h4 class="text-sm font-medium text-gray-700 mb-2">Harmony Colors</h4>
          <div class="harmony-colors" id="harmony-colors">
            <!-- Harmony colors will be generated here -->
          </div>
        </div>

        <div>
          <h4 class="text-sm font-medium text-gray-700 mb-2">Accessibility</h4>
          <div class="space-y-2">
            <div class="contrast-info">
              <p class="text-sm">White Text Contrast</p>
              <div class="contrast-badge" id="white-contrast-badge">4.5:1 ✓</div>
            </div>
            <div class="contrast-info">
              <p class="text-sm">Black Text Contrast</p>
              <div class="contrast-badge" id="black-contrast-badge">4.5:1 ✓</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- History Modal -->
  <div class="modal-backdrop hidden" id="history-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Palette History</h2>
        <button class="close-btn" id="close-history">&times;</button>
      </div>
      <div id="history-content">
        <p class="text-gray-600" id="no-history-message">No palette history available yet.</p>
        <div id="history-palettes">
          <!-- History palettes will be generated here -->
        </div>
      </div>
    </div>
  </div>

  <!-- Export Modal -->
  <div class="modal-backdrop hidden" id="export-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Export Palette as Code</h2>
        <button class="close-btn" id="close-export">&times;</button>
      </div>
      <div class="export-preview" id="export-preview">
        <!-- Export preview colors will be generated here -->
      </div>
      <div class="tabs export-tabs">
        <div class="tab-list">
          <div class="tab active" data-export-tab="css">CSS</div>
          <div class="tab" data-export-tab="scss">SCSS</div>
          <div class="tab" data-export-tab="tailwind">Tailwind</div>
          <div class="tab" data-export-tab="hex">Hex</div>
        </div>
        <div class="export-code" id="export-code">
          <!-- Export code will be generated here -->
        </div>
      </div>
      <div class="export-actions">
        <button class="btn btn-outline" id="download-code-btn">
          <svg class="icon" viewBox="0 0 24 24" width="16" height="16">
            <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"></path>
          </svg>
          Download
        </button>
        <button class="btn btn-primary" id="copy-code-btn">
          <svg class="icon" viewBox="0 0 24 24" width="16" height="16">
            <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path>
          </svg>
          Copy to Clipboard
        </button>
      </div>
    </div>
  </div>

  <!-- Import Modal -->
  <div class="modal-backdrop hidden" id="import-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Import Colors</h2>
        <button class="close-btn" id="close-import">&times;</button>
      </div>
      <div class="tabs export-tabs">
        <div class="tab-list">
          <div class="tab active" data-import-tab="hex">Hex Colors</div>
          <div class="tab" data-import-tab="css">CSS Code</div>
        </div>
        <div class="tab-content active" id="hex-import-tab">
          <p class="text-sm text-gray-600 mb-2">Enter hex colors (one per line, or comma/space separated)</p>
          <textarea class="import-input" id="hex-input" placeholder="#FF5733
#33FF57
#5733FF"></textarea>
          <div class="import-examples">
            <p>Examples:</p>
            <ul>
              <li>#FF5733</li>
              <li>FF5733 (# will be added automatically)</li>
              <li>#F53 (will be expanded to #FF5533)</li>
            </ul>
          </div>
        </div>
        <div class="tab-content" id="css-import-tab">
          <p class="text-sm text-gray-600 mb-2">Paste CSS code containing colors</p>
          <textarea class="import-input" id="css-input" placeholder=":root {
  --primary: #FF5733;
  --secondary: #33FF57;
  --accent: #5733FF;
}"></textarea>
          <div class="import-examples">
            <p>Supported formats:</p>
            <ul>
              <li>Hex colors (#FF5733)</li>
              <li>RGB colors (rgb(255, 87, 51))</li>
            </ul>
          </div>
        </div>
      </div>
      <div id="import-error" class="error-message hidden">
        <svg class="icon" viewBox="0 0 24 24" width="16" height="16">
          <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"></path>
        </svg>
        <span id="import-error-message">No valid colors found. Please check your input.</span>
      </div>
      <div class="export-actions">
        <button class="btn btn-primary" id="import-colors-btn">
          <svg class="icon" viewBox="0 0 24 24" width="16" height="16">
            <path d="M5 8v2h14V8H5zm0 8h4v-6h6v6h4L12 23 5 16z"></path>
          </svg>
          Import Colors
        </button>
      </div>
    </div>
  </div>

  <!-- Toast Container -->
  <div class="toast-container" id="toast-container">
    <!-- Toasts will be generated here -->
  </div>

  <script>
    // Color Utilities
    const colorUtils = {
      // Generate a random hex color
      generateRandomColor: function() {
        return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
      },

      // Generate a palette of random colors
      generateRandomPalette: function(count) {
        return Array.from({ length: count }, () => this.generateRandomColor());
      },

      // Convert hex color to RGB
      hexToRgb: function(hex) {
        // Remove the hash if it exists
        hex = hex.replace(/^#/, '');

        // Parse the hex values
        const bigint = parseInt(hex, 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;

        return { r, g, b };
      },

      // Convert RGB to hex
      rgbToHex: function(r, g, b) {
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
      },

      // Generate a harmonious color palette based on a seed color
      generateHarmoniousPalette: function(seedColor, count) {
        const { r, g, b } = this.hexToRgb(seedColor);
        const hsl = this.rgbToHsl(r, g, b);

        const palette = [seedColor];

        // Generate colors with evenly spaced hues
        const hueStep = 360 / count;

        for (let i = 1; i < count; i++) {
          const newHue = (hsl.h + i * hueStep) % 360;
          const { r: newR, g: newG, b: newB } = this.hslToRgb(newHue, hsl.s, hsl.l);
          palette.push(this.rgbToHex(newR, newG, newB));
        }

        return palette;
      },

      // Generate an analogous color palette
      generateAnalogousPalette: function(baseColor, count) {
        const { r, g, b } = this.hexToRgb(baseColor);
        const hsl = this.rgbToHsl(r, g, b);

        const palette = [baseColor];
        const hueStep = 30; // Analogous colors are typically 30 degrees apart

        // Generate colors on both sides of the base color
        const sideCount = Math.floor(count / 2);

        for (let i = 1; i <= sideCount; i++) {
          // Colors to the right
          const rightHue = (hsl.h + i * hueStep) % 360;
          const { r: rightR, g: rightG, b: rightB } = this.hslToRgb(rightHue, hsl.s, hsl.l);
          palette.push(this.rgbToHex(rightR, rightG, rightB));

          // Colors to the left if we need more
          if (palette.length < count) {
            const leftHue = (hsl.h - i * hueStep + 360) % 360;
            const { r: leftR, g: leftG, b: leftB } = this.hslToRgb(leftHue, hsl.s, hsl.l);
            palette.push(this.rgbToHex(leftR, leftG, leftB));
          }
        }

        // If we need one more color (for odd counts)
        if (palette.length < count) {
          const lastHue = (hsl.h + (sideCount + 1) * hueStep) % 360;
          const { r: lastR, g: lastG, b: lastB } = this.hslToRgb(lastHue, hsl.s, hsl.l);
          palette.push(this.rgbToHex(lastR, lastG, lastB));
        }

        return palette;
      },

      // Generate a monochromatic color palette
      generateMonochromaticPalette: function(baseColor, count) {
        const { r, g, b } = this.hexToRgb(baseColor);
        const hsl = this.rgbToHsl(r, g, b);

        const palette = [];

        // Vary lightness to create monochromatic palette
        for (let i = 0; i < count; i++) {
          const newLightness = 20 + (i * 60) / (count - 1); // Range from 20% to 80%
          const { r: newR, g: newG, b: newB } = this.hslToRgb(hsl.h, hsl.s, newLightness / 100);
          palette.push(this.rgbToHex(newR, newG, newB));
        }

        return palette;
      },

      // Generate a complementary color palette
      generateComplementaryPalette: function(baseColor, count) {
        const { r, g, b } = this.hexToRgb(baseColor);
        const hsl = this.rgbToHsl(r, g, b);

        // Complementary color (opposite on the color wheel)
        const complementaryHue = (hsl.h + 180) % 360;

        const palette = [baseColor];

        // Add variations of the base and complementary colors
        const variations = count - 2; // Excluding base and pure complementary

        if (variations > 0) {
          const variationsPerSide = Math.floor(variations / 2);

          // Add variations of the base color
          for (let i = 1; i <= variationsPerSide; i++) {
            const satFactor = 1 - i * 0.2;
            const { r: newR, g: newG, b: newB } = this.hslToRgb(hsl.h, hsl.s * satFactor, hsl.l);
            palette.push(this.rgbToHex(newR, newG, newB));
          }

          // Add the complementary color
          const { r: compR, g: compG, b: compB } = this.hslToRgb(complementaryHue, hsl.s, hsl.l);
          palette.push(this.rgbToHex(compR, compG, compB));

          // Add variations of the complementary color
          for (let i = 1; i <= variations - variationsPerSide; i++) {
            const satFactor = 1 - i * 0.2;
            const { r: newR, g: newG, b: newB } = this.hslToRgb(complementaryHue, hsl.s * satFactor, hsl.l);
            palette.push(this.rgbToHex(newR, newG, newB));
          }
        } else {
          // Just add the complementary color if we only need 2 colors
          const { r: compR, g: compG, b: compB } = this.hslToRgb(complementaryHue, hsl.s, hsl.l);
          palette.push(this.rgbToHex(compR, compG, compB));
        }

        return palette;
      },

      // Generate a triadic color palette
      generateTriadicPalette: function(baseColor, count) {
        const { r, g, b } = this.hexToRgb(baseColor);
        const hsl = this.rgbToHsl(r, g, b);

        // Triadic colors (120 degrees apart on the color wheel)
        const triad1Hue = (hsl.h + 120) % 360;
        const triad2Hue = (hsl.h + 240) % 360;

        const palette = [baseColor];

        // If we need more than 3 colors, add variations
        if (count <= 3) {
          // Just add the triadic colors
          const { r: t1R, g: t1G, b: t1B } = this.hslToRgb(triad1Hue, hsl.s, hsl.l);
          palette.push(this.rgbToHex(t1R, t1G, t1B));

          if (count === 3) {
            const { r: t2R, g: t2G, b: t2B } = this.hslToRgb(triad2Hue, hsl.s, hsl.l);
            palette.push(this.rgbToHex(t2R, t2G, t2B));
          }
        } else {
          // Add the triadic colors
          const { r: t1R, g: t1G, b: t1B } = this.hslToRgb(triad1Hue, hsl.s, hsl.l);
          const { r: t2R, g: t2G, b: t2B } = this.hslToRgb(triad2Hue, hsl.s, hsl.l);
          palette.push(this.rgbToHex(t1R, t1G, t1B));
          palette.push(this.rgbToHex(t2R, t2G, t2B));

          // Add variations to fill the remaining slots
          const remaining = count - 3;
          for (let i = 0; i < remaining; i++) {
            const hueOffset = (i * 30) % 360;
            const newHue = (hsl.h + hueOffset) % 360;
            const { r: newR, g: newG, b: newB } = this.hslToRgb(newHue, hsl.s * 0.8, hsl.l);
            palette.push(this.rgbToHex(newR, newG, newB));
          }
        }

        return palette;
      },

      // Generate a tetradic (rectangle) color palette
      generateTetradicPalette: function(baseColor, count) {
        const { r, g, b } = this.hexToRgb(baseColor);
        const hsl = this.rgbToHsl(r, g, b);

        // Tetradic colors (60 and 180 degrees apart)
        const tetra1Hue = (hsl.h + 60) % 360;
        const tetra2Hue = (hsl.h + 180) % 360;
        const tetra3Hue = (hsl.h + 240) % 360;

        const palette = [baseColor];

        // If we need more than 4 colors, add variations
        if (count <= 4) {
          // Just add the tetradic colors
          if (count >= 2) {
            const { r: t1R, g: t1G, b: t1B } = this.hslToRgb(tetra1Hue, hsl.s, hsl.l);
            palette.push(this.rgbToHex(t1R, t1G, t1B));
          }

          if (count >= 3) {
            const { r: t2R, g: t2G, b: t2B } = this.hslToRgb(tetra2Hue, hsl.s, hsl.l);
            palette.push(this.rgbToHex(t2R, t2G, t2B));
          }

          if (count === 4) {
            const { r: t3R, g: t3G, b: t3B } = this.hslToRgb(tetra3Hue, hsl.s, hsl.l);
            palette.push(this.rgbToHex(t3R, t3G, t3B));
          }
        } else {
          // Add the tetradic colors
          const { r: t1R, g: t1G, b: t1B } = this.hslToRgb(tetra1Hue, hsl.s, hsl.l);
          const { r: t2R, g: t2G, b: t2B } = this.hslToRgb(tetra2Hue, hsl.s, hsl.l);
          const { r: t3R, g: t3G, b: t3B } = this.hslToRgb(tetra3Hue, hsl.s, hsl.l);
          palette.push(this.rgbToHex(t1R, t1G, t1B));
          palette.push(this.rgbToHex(t2R, t2G, t2B));
          palette.push(this.rgbToHex(t3R, t3G, t3B));

          // Add variations to fill the remaining slots
          const remaining = count - 4;
          for (let i = 0; i < remaining; i++) {
            const baseIndex = i % 4;
            let baseHue;

            switch (baseIndex) {
              case 0:
                baseHue = hsl.h;
                break;
              case 1:
                baseHue = tetra1Hue;
                break;
              case 2:
                baseHue = tetra2Hue;
                break;
              case 3:
                baseHue = tetra3Hue;
                break;
              default:
                baseHue = hsl.h;
            }

            const { r: newR, g: newG, b: newB } = this.hslToRgb(baseHue, hsl.s * 0.7, (hsl.l * 1.2) % 1);
            palette.push(this.rgbToHex(newR, newG, newB));
          }
        }

        return palette;
      },

      // Convert RGB to HSL
      rgbToHsl: function(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h = 0,
          s,
          l = (max + min) / 2;

        if (max === min) {
          h = s = 0; // achromatic
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }

          h /= 6;
        }

        return { h: h * 360, s, l };
      },

      // Convert HSL to RGB
      hslToRgb: function(h, s, l) {
        h /= 360;

        let r, g, b;

        if (s === 0) {
          r = g = b = l; // achromatic
        } else {
          const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
          };

          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;

          r = hue2rgb(p, q, h + 1 / 3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1 / 3);
        }

        return {
          r: Math.round(r * 255),
          g: Math.round(g * 255),
          b: Math.round(b * 255),
        };
      },

      // Get a human-readable name for a color
      getColorName: function(hexColor) {
        const { r, g, b } = this.hexToRgb(hexColor);
        const hsl = this.rgbToHsl(r, g, b);

        // Basic color naming based on HSL values
        let name = "";

        // Determine lightness name
        if (hsl.l < 0.2) {
          name = "Dark ";
        } else if (hsl.l > 0.8) {
          name = "Light ";
        } else if (hsl.l > 0.6) {
          name = "Pale ";
        }

        // Determine saturation name
        if (hsl.s < 0.15) {
          if (hsl.l < 0.2) return "Black";
          if (hsl.l > 0.8) return "White";
          return `Gray (${Math.round(hsl.l * 100)}%)`;
        }

        if (hsl.s < 0.3) {
          name += "Muted ";
        } else if (hsl.s > 0.8) {
          name += "Vibrant ";
        }

        // Determine hue name
        if (hsl.h >= 0 && hsl.h < 30) {
          name += "Red";
        } else if (hsl.h >= 30 && hsl.h < 60) {
          name += "Orange";
        } else if (hsl.h >= 60 && hsl.h < 90) {
          name += "Yellow";
        } else if (hsl.h >= 90 && hsl.h < 150) {
          name += "Green";
        } else if (hsl.h >= 150 && hsl.h < 210) {
          name += "Cyan";
        } else if (hsl.h >= 210 && hsl.h < 270) {
          name += "Blue";
        } else if (hsl.h >= 270 && hsl.h < 330) {
          name += "Purple";
        } else {
          name += "Pink";
        }

        return name;
      },

      // Get harmonious colors for a given color
      getColorHarmony: function(hexColor) {
        const { r, g, b } = this.hexToRgb(hexColor);
        const hsl = this.rgbToHsl(r, g, b);

        const harmony = [];

        // Complementary
        const complementaryHue = (hsl.h + 180) % 360;
        const { r: compR, g: compG, b: compB } = this.hslToRgb(complementaryHue, hsl.s, hsl.l);
        harmony.push(this.rgbToHex(compR, compG, compB));

        // Analogous (30 degrees away)
        const analogous1Hue = (hsl.h + 30) % 360;
        const { r: ana1R, g: ana1G, b: ana1B } = this.hslToRgb(analogous1Hue, hsl.s, hsl.l);
        harmony.push(this.rgbToHex(ana1R, ana1G, ana1B));

        // Analogous (330 degrees away)
        const analogous2Hue = (hsl.h - 30 + 360) % 360;
        const { r: ana2R, g: ana2G, b: ana2B } = this.hslToRgb(analogous2Hue, hsl.s, hsl.l);
        harmony.push(this.rgbToHex(ana2R, ana2G, ana2B));

        // Triadic (120 degrees away)
        const triadic1Hue = (hsl.h + 120) % 360;
        const { r: tri1R, g: tri1G, b: tri1B } = this.hslToRgb(triadic1Hue, hsl.s, hsl.l);
        harmony.push(this.rgbToHex(tri1R, tri1G, tri1B));

        return harmony;
      },

      // Get accessibility information for a color
      getColorAccessibility: function(hexColor) {
        const { r, g, b } = this.hexToRgb(hexColor);

        // Calculate relative luminance
        const rsrgb = r / 255;
        const gsrgb = g / 255;
        const bsrgb = b / 255;

        const r1 = rsrgb <= 0.03928 ? rsrgb / 12.92 : Math.pow((rsrgb + 0.055) / 1.055, 2.4);
        const g1 = gsrgb <= 0.03928 ? gsrgb / 12.92 : Math.pow((gsrgb + 0.055) / 1.055, 2.4);
        const b1 = bsrgb <= 0.03928 ? bsrgb / 12.92 : Math.pow((bsrgb + 0.055) / 1.055, 2.4);

        const luminance = 0.2126 * r1 + 0.7152 * g1 + 0.0722 * b1;

        // Calculate contrast with white (luminance = 1)
        const whiteContrast = (1 + 0.05) / (luminance + 0.05);

        // Calculate contrast with black (luminance = 0)
        const blackContrast = (luminance + 0.05) / (0 + 0.05);

        return { whiteContrast, blackContrast };
      },

      // Convert RGB to CMYK
      rgbToCmyk: function(r, g, b) {
        let c = 1 - r / 255;
        let m = 1 - g / 255;
        let y = 1 - b / 255;
        const k = Math.min(c, m, y);

        if (k === 1) {
          return { c: 0, m: 0, y: 0, k: 1 };
        }

        c = (c - k) / (1 - k);
        m = (m - k) / (1 - k);
        y = (y - k) / (1 - k);

        return {
          c: Math.round(c * 100),
          m: Math.round(m * 100),
          y: Math.round(y * 100),
          k: Math.round(k * 100),
        };
      }
    };

    // Color Learning Engine
    class ColorLearningEngine {
      constructor() {
        this.likedColors = [];
        this.dislikedColors = [];
        this.colorFrequency = {};
        this.huePreferences = Array(36).fill(1); // 36 hue buckets (10 degrees each)
        this.saturationPreference = 0.5;
        this.lightnessPreference = 0.5;
        this.colorBias = { r: 0.5, g: 0.5, b: 0.5 };
      }

      // Learn from a palette that the user liked or disliked
      learnFromPalette(palette, sentiment) {
        palette.forEach((color) => {
          const { r, g, b } = colorUtils.hexToRgb(color);
          const { h, s, l } = colorUtils.rgbToHsl(r, g, b);

          // Update hue preferences
          const hueBucket = Math.floor(h / 10) % 36;
          this.huePreferences[hueBucket] += sentiment * 0.1;

          // Ensure values stay in reasonable range
          this.huePreferences[hueBucket] = Math.max(0.1, Math.min(2, this.huePreferences[hueBucket]));

          // Update saturation and lightness preferences (weighted average)
          const weight = 0.1;
          this.saturationPreference = (1 - weight) * this.saturationPreference + weight * sentiment * s;
          this.lightnessPreference = (1 - weight) * this.lightnessPreference + weight * sentiment * l;

          // Keep preferences in valid range
          this.saturationPreference = Math.max(0.1, Math.min(0.9, this.saturationPreference));
          this.lightnessPreference = Math.max(0.1, Math.min(0.9, this.lightnessPreference));

          // Update color bias
          this.colorBias.r = (1 - weight) * this.colorBias.r + weight * sentiment * (r / 255);
          this.colorBias.g = (1 - weight) * this.colorBias.g + weight * sentiment * (g / 255);
          this.colorBias.b = (1 - weight) * this.colorBias.b + weight * sentiment * (b / 255);

          // Keep bias in valid range
          this.colorBias.r = Math.max(0.1, Math.min(0.9, this.colorBias.r));
          this.colorBias.g = Math.max(0.1, Math.min(0.9, this.colorBias.g));
          this.colorBias.b = Math.max(0.1, Math.min(0.9, this.colorBias.b));

          // Add to liked or disliked colors
          if (sentiment > 0) {
            if (!this.likedColors.includes(color)) {
              this.likedColors.push(color);
            }
          } else {
            if (!this.dislikedColors.includes(color)) {
              this.dislikedColors.push(color);
            }
          }

          // Update color frequency
          const colorKey = `${r},${g},${b}`;
          this.colorFrequency[colorKey] = (this.colorFrequency[colorKey] || 0) + 1;
        });
      }

      // Generate a palette based on learned preferences
      generatePalette(count, creativity = 0.5) {
        const palette = [];

        // Start with a seed color based on preferences
        const seedColor = this.generatePreferredColor(creativity);
        palette.push(seedColor);

        // Generate remaining colors
        for (let i = 1; i < count; i++) {
          // Mix between harmony-based and preference-based generation
          if (Math.random() < 0.7) {
            // Generate a color that harmonizes with existing colors
            const baseColor = palette[Math.floor(Math.random() * palette.length)];
            const { r, g, b } = colorUtils.hexToRgb(baseColor);
            const { h, s, l } = colorUtils.rgbToHsl(r, g, b);

            // Apply a hue shift based on color theory
            let hueShift;
            const harmonyType = Math.random();

            if (harmonyType < 0.3) {
              // Analogous
              hueShift = Math.random() * 40 - 20;
            } else if (harmonyType < 0.6) {
              // Complementary
              hueShift = 180 + (Math.random() * 20 - 10);
            } else if (harmonyType < 0.8) {
              // Triadic
              hueShift = 120 * (Math.floor(Math.random() * 2) + 1) + (Math.random() * 20 - 10);
            } else {
              // Split complementary
              hueShift = 180 + (Math.random() > 0.5 ? 30 : -30) + (Math.random() * 20 - 10);
            }

            const newHue = (h + hueShift + 360) % 360;

            // Vary saturation and lightness slightly
            const newSat = Math.max(0.1, Math.min(0.9, s * (0.8 + Math.random() * 0.4)));
            const newLight = Math.max(0.1, Math.min(0.9, l * (0.8 + Math.random() * 0.4)));

            const { r: newR, g: newG, b: newB } = colorUtils.hslToRgb(newHue, newSat, newLight);
            const newColor = colorUtils.rgbToHex(newR, newG, newB);

            // Check if too similar to existing colors
            if (!this.isTooSimilar(newColor, palette, 30)) {
              palette.push(newColor);
            } else {
              // If too similar, generate a preferred color instead
              palette.push(this.generatePreferredColor(creativity));
            }
          } else {
            // Generate a color based on learned preferences
            palette.push(this.generatePreferredColor(creativity));
          }
        }

        return palette;
      }

      // Generate a color based on learned preferences
      generatePreferredColor(creativity) {
        // Occasionally use a previously liked color
        if (this.likedColors.length > 0 && Math.random() > creativity) {
          return this.likedColors[Math.floor(Math.random() * this.likedColors.length)];
        }

        // Generate a new color based on preferences
        // Select a hue based on weighted preferences
        const hueWeights = [...this.huePreferences];
        const totalWeight = hueWeights.reduce((sum, weight) => sum + weight, 0);
        let randomWeight = Math.random() * totalWeight;
        let selectedHueBucket = 0;

        for (let i = 0; i < hueWeights.length; i++) {
          randomWeight -= hueWeights[i];
          if (randomWeight <= 0) {
            selectedHueBucket = i;
            break;
          }
        }

        // Convert bucket to hue value (0-360)
        let hue = selectedHueBucket * 10 + Math.random() * 10;

        // Add some randomness based on creativity
        hue = (hue + creativity * Math.random() * 60 - 30 + 360) % 360;

        // Use preferred saturation and lightness with some variation
        const saturation = Math.max(
          0.1,
          Math.min(0.9, this.saturationPreference * (1 - creativity * 0.5) + Math.random() * creativity * 0.8)
        );

        const lightness = Math.max(
          0.1,
          Math.min(0.9, this.lightnessPreference * (1 - creativity * 0.5) + Math.random() * creativity * 0.8)
        );

        // Convert to RGB and apply color bias
        let { r, g, b } = colorUtils.hslToRgb(hue, saturation, lightness);

        // Apply color bias if creativity is low
        if (creativity < 0.7) {
          const biasStrength = 0.3 * (1 - creativity);
          r = Math.round(r * (1 - biasStrength) + 255 * this.colorBias.r * biasStrength);
          g = Math.round(g * (1 - biasStrength) + 255 * this.colorBias.g * biasStrength);
          b = Math.round(b * (1 - biasStrength) + 255 * this.colorBias.b * biasStrength);
        }

        // Ensure we avoid disliked colors
        const newColor = colorUtils.rgbToHex(r, g, b);
        if (this.isDisliked(newColor)) {
          // If disliked, try again with more creativity
          return this.generatePreferredColor(Math.min(1, creativity + 0.2));
        }

        return newColor;
      }

      // Check if a color is too similar to colors in a palette
      isTooSimilar(color, palette, threshold) {
        const { r: r1, g: g1, b: b1 } = colorUtils.hexToRgb(color);

        for (const existingColor of palette) {
          const { r: r2, g: g2, b: b2 } = colorUtils.hexToRgb(existingColor);

          // Calculate color distance (Euclidean distance in RGB space)
          const distance = Math.sqrt(Math.pow(r1 - r2, 2) + Math.pow(g1 - g2, 2) + Math.pow(b1 - b2, 2));

          if (distance < threshold) {
            return true;
          }
        }

        return false;
      }

      // Check if a color is similar to disliked colors
      isDisliked(color) {
        if (this.dislikedColors.length === 0) return false;

        const { r: r1, g: g1, b: b1 } = colorUtils.hexToRgb(color);

        for (const dislikedColor of this.dislikedColors) {
          const { r: r2, g: g2, b: b2 } = colorUtils.hexToRgb(dislikedColor);

          // Calculate color distance
          const distance = Math.sqrt(Math.pow(r1 - r2, 2) + Math.pow(g1 - g2, 2) + Math.pow(b1 - b2, 2));

          if (distance < 30) {
            return true;
          }
        }

        return false;
      }

      // Set color bias directly
      setColorBias(bias) {
        this.colorBias = { ...bias };
      }

      // Set saturation preference directly
      setSaturationPreference(value) {
        this.saturationPreference = Math.max(0.1, Math.min(0.9, value));
      }

      // Set lightness preference directly
      setLightnessPreference(value) {
        this.lightnessPreference = Math.max(0.1, Math.min(0.9, value));
      }

      // Reset all preferences
      resetPreferences() {
        this.huePreferences = Array(36).fill(1);
        this.saturationPreference = 0.5;
        this.lightnessPreference = 0.5;
        this.colorBias = { r: 0.5, g: 0.5, b: 0.5 };
      }

      // Reset everything
      reset() {
        this.likedColors = [];
        this.dislikedColors = [];
        this.colorFrequency = {};
        this.resetPreferences();
      }

      // Save learning data to JSON string
      saveToJSON() {
        return JSON.stringify({
          likedColors: this.likedColors,
          dislikedColors: this.dislikedColors,
          colorFrequency: this.colorFrequency,
          huePreferences: this.huePreferences,
          saturationPreference: this.saturationPreference,
          lightnessPreference: this.lightnessPreference,
          colorBias: this.colorBias,
        });
      }

      // Load learning data from JSON string
      loadFromJSON(json) {
        try {
          const data = JSON.parse(json);
          this.likedColors = data.likedColors || [];
          this.dislikedColors = data.dislikedColors || [];
          this.colorFrequency = data.colorFrequency || {};
          this.huePreferences = data.huePreferences || Array(36).fill(1);
          this.saturationPreference = data.saturationPreference || 0.5;
          this.lightnessPreference = data.lightnessPreference || 0.5;
          this.colorBias = data.colorBias || { r: 0.5, g: 0.5, b: 0.5 };
        } catch (e) {
          console.error("Error loading learning data:", e);
          this.reset();
        }
      }

      // Get statistics about the learning engine
      getTotalSamples() {
        return this.likedColors.length + this.dislikedColors.length;
      }

      getLikedColorsCount() {
        return this.likedColors.length;
      }

      getDislikedColorsCount() {
        return this.dislikedColors.length;
      }

      getConfidenceScore() {
        const totalSamples = this.getTotalSamples();
        if (totalSamples === 0) return 0;

        // Calculate confidence based on number of samples and preference strength
        const maxSamples = 50; // Arbitrary number for max confidence
        const sampleConfidence = Math.min(1, totalSamples / maxSamples);

        // Calculate preference strength
        const preferenceStrength =
          this.huePreferences.reduce((sum, weight) => {
            // How far from neutral (1) is this weight?
            return sum + Math.abs(weight - 1);
          }, 0) / this.huePreferences.length;

        return sampleConfidence * (0.5 + preferenceStrength * 0.5);
      }
    }

    // App State
    const appState = {
      currentPalette: [],
      paletteHistory: [],
      selectedColorIndex: null,
      generationMode: 'random',
      learningEngine: new ColorLearningEngine(),
      creativity: 50,
      colorPreference: 'balanced',
      exportFormat: 'css',
      importType: 'hex',
      activeTab: 'palette',
      activeExportTab: 'css',
      activeImportTab: 'hex',
      isTraining: false,
      trainingProgress: 0,
      currentColorFormat: 'HEX'
    };

    // DOM Elements
    const elements = {
      colorPalette: document.getElementById('color-palette'),
      generateBtn: document.getElementById('generate-btn'),
      historyBtn: document.getElementById('history-btn'),
      formatBtn: document.getElementById('format-btn'),
      currentFormat: document.getElementById('current-format'),
      likeBtn: document.getElementById('like-btn'),
      dislikeBtn: document.getElementById('dislike-btn'),
      exportBtn: document.getElementById('export-btn'),
      importBtn: document.getElementById('import-btn'),
      generationMode: document.getElementById('generation-mode'),
      tabs: document.querySelectorAll('.tab'),
      tabContents: document.querySelectorAll('.tab-content'),
      
      // Color Info Modal
      colorInfoModal: document.getElementById('color-info-modal'),
      closeColorInfo: document.getElementById('close-color-info'),
      colorPreview: document.getElementById('color-preview'),
      colorName: document.getElementById('color-name'),
      colorHexValue: document.getElementById('color-hex-value'),
      rgbValue: document.getElementById('rgb-value'),
      hslValue: document.getElementById('hsl-value'),
      cmykValue: document.getElementById('cmyk-value'),
      hexValue: document.getElementById('hex-value'),
      harmonyColors: document.getElementById('harmony-colors'),
      whiteContrastBadge: document.getElementById('white-contrast-badge'),
      blackContrastBadge: document.getElementById('black-contrast-badge'),
      copyColorBtn: document.getElementById('copy-color-btn'),
      
      // History Modal
      historyModal: document.getElementById('history-modal'),
      closeHistory: document.getElementById('close-history'),
      historyContent: document.getElementById('history-content'),
      noHistoryMessage: document.getElementById('no-history-message'),
      historyPalettes: document.getElementById('history-palettes'),
      
      // Export Modal
      exportModal: document.getElementById('export-modal'),
      closeExport: document.getElementById('close-export'),
      exportPreview: document.getElementById('export-preview'),
      exportCode: document.getElementById('export-code'),
      exportTabs: document.querySelectorAll('[data-export-tab]'),
      downloadCodeBtn: document.getElementById('download-code-btn'),
      copyCodeBtn: document.getElementById('copy-code-btn'),
      
      // Import Modal
      importModal: document.getElementById('import-modal'),
      closeImport: document.getElementById('close-import'),
      hexInput: document.getElementById('hex-input'),
      cssInput: document.getElementById('css-input'),
      importTabs: document.querySelectorAll('[data-import-tab]'),
      importError: document.getElementById('import-error'),
      importErrorMessage: document.getElementById('import-error-message'),
      importColorsBtn: document.getElementById('import-colors-btn'),
      
      // Algorithm Features
      totalSamples: document.getElementById('total-samples'),
      confidenceBar: document.getElementById('confidence-bar'),
      confidenceValue: document.getElementById('confidence-value'),
      trainAiBtn: document.getElementById('train-algorithm-btn'),
      resetAiBtn: document.getElementById('reset-algorithm-btn'),
      creativitySlider: document.getElementById('creativity-slider'),
      creativityValue: document.getElementById('creativity-value'),
      preferenceButtons: document.querySelectorAll('[data-preference]'),
      generateAiBtn: document.getElementById('generate-smart-btn'),
      likedColorsBar: document.getElementById('liked-colors-bar'),
      likedColorsCount: document.getElementById('liked-colors-count'),
      dislikedColorsBar: document.getElementById('disliked-colors-bar'),
      dislikedColorsCount: document.getElementById('disliked-colors-count'),
      
      // Toast Container
      toastContainer: document.getElementById('toast-container'),
      
      // Canvas
      backgroundCanvas: document.getElementById('background-canvas')
    };

    // Initialize the app
    function initApp() {
      // Load saved data from localStorage
      loadFromLocalStorage();

      // Detect browser and add appropriate classes
      const ua = navigator.userAgent;
      let browserClass = '';

      if (/iPad|iPhone|iPod/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1)) {
        document.body.classList.add('is-ios');
        browserClass = 'is-ios';
      }

      if (/Android/.test(ua)) {
        document.body.classList.add('is-android');
        browserClass = 'is-android';
      }

      if (/Edge/.test(ua)) {
        document.body.classList.add('is-edge');
        browserClass = 'is-edge';
      }

      if (/Firefox/.test(ua)) {
        document.body.classList.add('is-firefox');
        browserClass = 'is-firefox';
      }

      if (/Chrome/.test(ua)) {
        document.body.classList.add('is-chrome');
        browserClass = 'is-chrome';
      }

      if (/Safari/.test(ua) && !/Chrome/.test(ua)) {
        document.body.classList.add('is-safari');
        browserClass = 'is-safari';
      }

      // Add touch detection
      if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
        document.body.classList.add('is-touch-device');
      }

      // Add responsive class
      const updateResponsiveClass = () => {
        if (window.innerWidth <= 480) {
          document.body.classList.add('is-mobile');
          document.body.classList.remove('is-tablet', 'is-desktop');
        } else if (window.innerWidth <= 768) {
          document.body.classList.add('is-tablet');
          document.body.classList.remove('is-mobile', 'is-desktop');
        } else {
          document.body.classList.add('is-desktop');
          document.body.classList.remove('is-mobile', 'is-tablet');
        }
      };

      updateResponsiveClass();
      window.addEventListener('resize', updateResponsiveClass);
      
      // Generate initial palette if needed
      if (appState.currentPalette.length === 0) {
        appState.currentPalette = colorUtils.generateRandomPalette(5);
        saveToLocalStorage();
      }
      
      // Render the initial palette
      renderColorPalette();
      
      // Update AI stats
      updateAlgorithmStats();
      
      // Initialize animated background
      initAnimatedBackground();
      
      // Set up event listeners
      setupEventListeners();
    }

    // Load data from localStorage
    function loadFromLocalStorage() {
      try {
        const savedPalette = localStorage.getItem('currentPalette');
        const savedHistory = localStorage.getItem('paletteHistory');
        const savedLearningData = localStorage.getItem('learningData');
        const savedColorFormat = localStorage.getItem('currentColorFormat');
        
        if (savedPalette) {
          appState.currentPalette = JSON.parse(savedPalette);
        }
        
        if (savedHistory) {
          appState.paletteHistory = JSON.parse(savedHistory);
        }
        
        if (savedLearningData) {
          appState.learningEngine.loadFromJSON(savedLearningData);
        }
        
        if (savedColorFormat) {
          appState.currentColorFormat = savedColorFormat;
        }
      } catch (error) {
        console.error('Error loading from localStorage:', error);
      }
    }

    // Save data to localStorage
    function saveToLocalStorage() {
      try {
        localStorage.setItem('currentPalette', JSON.stringify(appState.currentPalette));
        localStorage.setItem('paletteHistory', JSON.stringify(appState.paletteHistory));
        localStorage.setItem('learningData', JSON.stringify(appState.learningEngine.saveToJSON()));
        localStorage.setItem('currentColorFormat', appState.currentColorFormat);
      } catch (error) {
        console.error('Error saving to localStorage:', error);
      }
    }

    // Render the color palette
    function renderColorPalette() {
      elements.colorPalette.innerHTML = '';
      
      // Update the format display in the button to ensure it's in sync
      elements.currentFormat.textContent = appState.currentColorFormat;
      
      appState.currentPalette.forEach((color, index) => {
        const card = document.createElement('div');
        card.className = 'color-card';
        
        const isLightColor = isColorLight(color);
        const textColor = isLightColor ? 'text-gray-800' : 'text-white';
        
        // Get the formatted color value based on the global format setting
        const formattedValue = getFormattedColorValue(color, index);
        
        card.innerHTML = `
          <div class="color-display" style="background-color: ${color}" data-index="${index}">
            <div class="flex justify-between">
              <button class="color-info-btn ${textColor} bg-white/20 hover:bg-white/30 p-1 rounded" aria-label="View color details">
                <svg class="icon" viewBox="0 0 24 24" width="16" height="16">
                  <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"></path>
                </svg>
              </button>
            </div>
            <p class="color-info ${textColor} font-mono truncate mt-auto">${formattedValue}</p>
          </div>
          <div class="color-controls">
            <input type="color" value="${color}" class="color-picker" data-index="${index}" aria-label="Change color ${index + 1}">
            <button class="copy-btn p-2 rounded-full hover:bg-gray-100" aria-label="Copy color code">
              <svg class="icon" viewBox="0 0 24 24" width="16" height="16">
                <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path>
              </svg>
            </button>
          </div>
        `;
        
        elements.colorPalette.appendChild(card);
        
        // Add event listeners for this card
        const colorDisplay = card.querySelector('.color-display');
        const colorPicker = card.querySelector('.color-picker');
        const copyBtn = card.querySelector('.copy-btn');
        const colorInfoBtn = card.querySelector('.color-info-btn');
        
        colorDisplay.addEventListener('click', () => {
          showColorInfo(index);
        });
        
        colorPicker.addEventListener('input', (e) => {
          updateColor(index, e.target.value);
        });
        
        copyBtn.addEventListener('click', () => {
          copyToClipboard(formattedValue);
        });
        
        colorInfoBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          showColorInfo(index);
        });
      });
    }

    // Check if a color is light (for text contrast)
    function isColorLight(color) {
      const hex = color.replace('#', '');
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      
      // Calculate perceived brightness
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;
      return brightness > 128;
    }

    // Update a color in the palette
    function updateColor(index, color) {
      appState.currentPalette[index] = color;
      renderColorPalette();
      updateAnimatedBackground();
      saveToLocalStorage();
    }

    // Copy a color to clipboard
    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        showToast('Copied!', `${text} copied to clipboard`);
      }).catch(err => {
        console.error('Could not copy text: ', err);
      });
    }

    // Replace the setColorFormat function with a simpler cycleColorFormat function:
    function cycleColorFormat() {
      // Determine the next format in the cycle
      switch (appState.currentColorFormat) {
        case 'HEX':
          appState.currentColorFormat = 'RGB';
          break;
        case 'RGB':
          appState.currentColorFormat = 'HSL';
          break;
        case 'HSL':
          appState.currentColorFormat = 'CSS';
          break;
        case 'CSS':
          appState.currentColorFormat = 'TW';
          break;
        case 'TW':
          appState.currentColorFormat = 'HEX';
          break;
        default:
          appState.currentColorFormat = 'HEX';
      }
      
      // Force a complete re-render of the palette
      renderColorPalette();
      
      // Save the format preference
      saveToLocalStorage();
      
      // Show a toast notification
      showToast('Format Changed', `All colors now showing in ${appState.currentColorFormat} format`);
    }

    // New function to get formatted color value based on format
    function getFormattedColorValue(color, index) {
      // Ensure we have a valid color
      if (!color || typeof color !== 'string') {
        return '#000000';
      }
      
      // Normalize the color to ensure it's a valid hex
      const normalizedColor = color.startsWith('#') ? color : '#' + color;
      
      try {
        const rgb = colorUtils.hexToRgb(normalizedColor);
        
        switch (appState.currentColorFormat) {
          case 'RGB':
            return `RGB(${rgb.r}, ${rgb.g}, ${rgb.b})`;
          case 'HSL': {
            const hsl = colorUtils.rgbToHsl(rgb.r, rgb.g, rgb.b);
            return `HSL(${Math.round(hsl.h)}°, ${Math.round(hsl.s * 100)}%, ${Math.round(hsl.l * 100)}%)`;
          }
          case 'CSS':
            return `var(--color-${index + 1})`;
          case 'TW':
            return `palette-${index + 1}`;
          case 'HEX':
          default:
            return normalizedColor.toUpperCase();
        }
      } catch (error) {
        console.error('Error formatting color:', error);
        return normalizedColor.toUpperCase();
      }
    }

    // Show color info modal
    function showColorInfo(index) {
      appState.selectedColorIndex = index;
      const color = appState.currentPalette[index];
      const rgb = colorUtils.hexToRgb(color);
      const hsl = colorUtils.rgbToHsl(rgb.r, rgb.g, rgb.b);
      const cmyk = colorUtils.rgbToCmyk(rgb.r, rgb.g, rgb.b);
      const colorName = colorUtils.getColorName(color);
      const harmony = colorUtils.getColorHarmony(color);
      const accessibility = colorUtils.getColorAccessibility(color);
      
      // Update modal content
      elements.colorPreview.style.backgroundColor = color;
      elements.colorName.textContent = colorName;
      elements.colorHexValue.textContent = color.toUpperCase();
      elements.rgbValue.textContent = `${rgb.r}, ${rgb.g}, ${rgb.b}`;
      elements.hslValue.textContent = `${Math.round(hsl.h)}°, ${Math.round(hsl.s * 100)}%, ${Math.round(hsl.l * 100)}%`;
      elements.cmykValue.textContent = `${cmyk.c}, ${cmyk.m}, ${cmyk.y}, ${cmyk.k}`;
      elements.hexValue.textContent = color.toUpperCase();
      
      // Update harmony colors
      elements.harmonyColors.innerHTML = '';
      harmony.forEach(harmonyColor => {
        const colorDiv = document.createElement('div');
        colorDiv.className = 'harmony-color';
        colorDiv.style.backgroundColor = harmonyColor;
        colorDiv.title = harmonyColor;
        colorDiv.addEventListener('click', () => copyToClipboard(harmonyColor));
        elements.harmonyColors.appendChild(colorDiv);
      });
      
      // Update contrast info
      const whiteContrast = accessibility.whiteContrast.toFixed(2);
      const blackContrast = accessibility.blackContrast.toFixed(2);
      
      elements.whiteContrastBadge.textContent = `${whiteContrast}:1 ${accessibility.whiteContrast >= 4.5 ? '✓' : '✗'}`;
      elements.whiteContrastBadge.className = `contrast-badge ${accessibility.whiteContrast >= 4.5 ? 'contrast-pass' : 'contrast-fail'}`;
      
      elements.blackContrastBadge.textContent = `${blackContrast}:1 ${accessibility.blackContrast >= 4.5 ? '✓' : '✗'}`;
      elements.blackContrastBadge.className = `contrast-badge ${accessibility.blackContrast >= 4.5 ? 'contrast-pass' : 'contrast-fail'}`;
      
      // Show the modal
      elements.colorInfoModal.classList.remove('hidden');
    }

    // Generate a new palette
    function generateNewPalette() {
      // Add current palette to history
      if (appState.currentPalette.length > 0) {
        appState.paletteHistory = [appState.currentPalette, ...appState.paletteHistory].slice(0, 5);
      }
      
      // Generate new palette based on selected mode
      let newPalette = [];
      const mode = appState.generationMode;
      
      switch (mode) {
        case 'smart':
          newPalette = appState.learningEngine.generatePalette(5, appState.creativity / 100);
          showToast('Smart Palette Generated', `Created with ${appState.creativity}% creativity level`);
          break;
        case 'harmonious':
          const seedColor = appState.currentPalette[0] || colorUtils.generateRandomColor();
          newPalette = colorUtils.generateHarmoniousPalette(seedColor, 5);
          break;
        case 'analogous':
          const baseColor = appState.currentPalette[0] || colorUtils.generateRandomColor();
          newPalette = colorUtils.generateAnalogousPalette(baseColor, 5);
          break;
        case 'monochromatic':
          const monoBase = appState.currentPalette[0] || colorUtils.generateRandomColor();
          newPalette = colorUtils.generateMonochromaticPalette(monoBase, 5);
          break;
        case 'complementary':
          const compBase = appState.currentPalette[0] || colorUtils.generateRandomColor();
          newPalette = colorUtils.generateComplementaryPalette(compBase, 5);
          break;
        case 'triadic':
          const triBase = appState.currentPalette[0] || colorUtils.generateRandomColor();
          newPalette = colorUtils.generateTriadicPalette(triBase, 5);
          break;
        case 'tetradic':
          const tetraBase = appState.currentPalette[0] || colorUtils.generateRandomColor();
          newPalette = colorUtils.generateTetradicPalette(tetraBase, 5);
          break;
        case 'random':
        default:
          newPalette = colorUtils.generateRandomPalette(5);
          break;
      }
      
      appState.currentPalette = newPalette;
      renderColorPalette();
      updateAnimatedBackground();
      saveToLocalStorage();
    }

    // Show history modal
    function showHistory() {
      // Update history content
      if (appState.paletteHistory.length === 0) {
        elements.noHistoryMessage.classList.remove('hidden');
        elements.historyPalettes.classList.add('hidden');
      } else {
        elements.noHistoryMessage.classList.add('hidden');
        elements.historyPalettes.classList.remove('hidden');
        
        // Render history palettes
        elements.historyPalettes.innerHTML = '';
        appState.paletteHistory.forEach((palette, index) => {
          const historyItem = document.createElement('div');
          historyItem.className = 'history-palette';
          
          const colorsDiv = document.createElement('div');
          colorsDiv.className = 'history-colors';
          
          palette.forEach(color => {
            const colorDiv = document.createElement('div');
            colorDiv.className = 'history-color';
            colorDiv.style.backgroundColor = color;
            colorsDiv.appendChild(colorDiv);
          });
          
          const infoDiv = document.createElement('div');
          infoDiv.className = 'history-info';
          infoDiv.innerHTML = `
            <span>Palette #${index + 1}</span>
            <span>Click to select</span>
          `;
          
          historyItem.appendChild(colorsDiv);
          historyItem.appendChild(infoDiv);
          
          historyItem.addEventListener('click', () => {
            selectHistoryPalette(palette);
          });
          
          elements.historyPalettes.appendChild(historyItem);
        });
      }
      
      // Show the modal
      elements.historyModal.classList.remove('hidden');
    }

    // Select a palette from history
    function selectHistoryPalette(palette) {
      // Add current palette to history before replacing it
      appState.paletteHistory = appState.paletteHistory.filter(p => JSON.stringify(p) !== JSON.stringify(palette));
      appState.paletteHistory = [appState.currentPalette, ...appState.paletteHistory].slice(0, 5);
      
      // Set the selected palette as current
      appState.currentPalette = [...palette];
      renderColorPalette();
      updateAnimatedBackground();
      saveToLocalStorage();
      
      // Hide the history modal
      elements.historyModal.classList.add('hidden');
    }

    // Like current palette
    function likePalette() {
      if (appState.currentPalette.length > 0) {
        appState.learningEngine.learnFromPalette(appState.currentPalette, 1); // 1 = liked
        updateAlgorithmStats();
        saveToLocalStorage();
        showToast('Palette Liked!', 'The algorithm will learn from your preference');
      }
    }

    // Dislike current palette
    function dislikePalette() {
      if (appState.currentPalette.length > 0) {
        appState.learningEngine.learnFromPalette(appState.currentPalette, -1); // -1 = disliked
        updateAlgorithmStats();
        saveToLocalStorage();
        showToast('Palette Disliked', 'The algorithm will avoid similar palettes');
      }
    }

    // Show export modal
    function showExport() {
      // Update export preview
      elements.exportPreview.innerHTML = '';
      appState.currentPalette.forEach(color => {
        const colorDiv = document.createElement('div');
        colorDiv.className = 'export-color';
        colorDiv.style.backgroundColor = color;
        elements.exportPreview.appendChild(colorDiv);
      });
      
      // Set active export tab
      setActiveExportTab(appState.exportFormat);
      
      // Show the modal
      elements.exportModal.classList.remove('hidden');
    }

    // Set active export tab
    function setActiveExportTab(format) {
      appState.exportFormat = format;
      
      // Update tab UI
      elements.exportTabs.forEach(tab => {
        if (tab.dataset.exportTab === format) {
          tab.classList.add('active');
        } else {
          tab.classList.remove('active');
        }
      });
      
      // Update export code
      updateExportCode();
    }

    // Update export code based on selected format
    function updateExportCode() {
      let code = '';
      
      switch (appState.exportFormat) {
        case 'css':
          code = generateCSSVariables();
          break;
        case 'scss':
          code = generateSCSSVariables();
          break;
        case 'tailwind':
          code = generateTailwindConfig();
          break;
        case 'hex':
          code = generateHexList();
          break;
      }
      
      elements.exportCode.textContent = code;
    }

    // Generate CSS variables
    function generateCSSVariables() {
      let cssCode = ":root {\n";
      appState.currentPalette.forEach((color, index) => {
        cssCode += `  --color-${index + 1}: ${color};\n`;
      });
      cssCode += "}";
      return cssCode;
    }

    // Generate SCSS variables
    function generateSCSSVariables() {
      let scssCode = "";
      appState.currentPalette.forEach((color, index) => {
        scssCode += `$color-${index + 1}: ${color};\n`;
      });
      return scssCode;
    }

    // Generate Tailwind config
    function generateTailwindConfig() {
      let tailwindCode = "// Add this to your tailwind.config.js\n";
      tailwindCode += "module.exports = {\n";
      tailwindCode += "  theme: {\n";
      tailwindCode += "    extend: {\n";
      tailwindCode += "      colors: {\n";

      appState.currentPalette.forEach((color, index) => {
        const colorName = `palette-${index + 1}`;
        tailwindCode += `        '${colorName}': '${color}',\n`;
      });

      tailwindCode += "      }\n";
      tailwindCode += "    }\n";
      tailwindCode += "  }\n";
      tailwindCode += "}";

      return tailwindCode;
    }

    // Generate simple hex list
    function generateHexList() {
      return appState.currentPalette.join("\n");
    }

    // Download export code
    function downloadExportCode() {
      const code = elements.exportCode.textContent;
      const fileExtension = appState.exportFormat === "tailwind" ? "js" : appState.exportFormat;
      const fileName = `palette-export.${fileExtension}`;

      const blob = new Blob([code], { type: "text/plain" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();

      // Clean up
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showToast('Download Complete', `Saved as ${fileName}`);
    }

    // Show import modal
    function showImport() {
      // Reset import form
      elements.hexInput.value = '';
      elements.cssInput.value = '';
      elements.importError.classList.add('hidden');
      
      // Set active import tab
      setActiveImportTab(appState.importType);
      
      // Show the modal
      elements.importModal.classList.remove('hidden');
    }

    // Set active import tab
    function setActiveImportTab(type) {
      appState.importType = type;
      
      // Update tab UI
      elements.importTabs.forEach(tab => {
        if (tab.dataset.importTab === type) {
          tab.classList.add('active');
        } else {
          tab.classList.remove('active');
        }
      });
      
      // Show/hide corresponding content
      if (type === 'hex') {
        document.getElementById('hex-import-tab').classList.add('active');
        document.getElementById('css-import-tab').classList.remove('active');
      } else {
        document.getElementById('hex-import-tab').classList.remove('active');
        document.getElementById('css-import-tab').classList.add('active');
      }
    }

    // Import colors
    function importColors() {
      elements.importError.classList.add('hidden');
      
      let extractedColors = [];
      
      if (appState.importType === 'hex') {
        extractedColors = extractHexColors(elements.hexInput.value);
      } else {
        extractedColors = extractCssColors(elements.cssInput.value);
      }
      
      if (extractedColors.length === 0) {
        elements.importError.classList.remove('hidden');
        elements.importErrorMessage.textContent = 'No valid colors found. Please check your input.';
        return;
      }
      
      // Limit to 5 colors for the palette
      const colorsToImport = extractedColors.slice(0, 5);
      
      // If less than 5 colors, fill with the last color
      while (colorsToImport.length < 5) {
        colorsToImport.push(colorsToImport[colorsToImport.length - 1] || '#000000');
      }
      
      // Add current palette to history
      if (appState.currentPalette.length > 0) {
        appState.paletteHistory = [appState.currentPalette, ...appState.paletteHistory].slice(0, 5);
      }
      
      // Set the imported colors as current palette
      appState.currentPalette = colorsToImport;
      renderColorPalette();
      updateAnimatedBackground();
      saveToLocalStorage();
      
      // Hide the import modal
      elements.importModal.classList.add('hidden');
      
      showToast('Colors Imported', `Imported ${colorsToImport.length} colors to your palette`);
    }

    // Extract hex colors from input
    function extractHexColors(input) {
      // Split by newlines, commas, or spaces
      const parts = input.split(/[\n,\s]+/).filter(Boolean);
      
      // Process each part to ensure it's a valid hex color
      return parts
        .map(part => {
          let color = part.trim();
          
          // Add # if missing
          if (!color.startsWith('#')) {
            color = '#' + color;
          }
          
          // Expand 3-digit hex to 6-digit
          if (/^#[0-9A-Fa-f]{3}$/.test(color)) {
            color = '#' + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
          }
          
          return color;
        })
        .filter(color => /^#[0-9A-Fa-f]{6}$/.test(color));
    }

    // Extract colors from CSS input
    function extractCssColors(input) {
      const colors = [];
      
      // Match hex colors
      const hexMatches = input.match(/#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})/g);
      if (hexMatches) {
        colors.push(...hexMatches);
      }
      
      // Match rgb/rgba colors
      const rgbMatches = input.match(/rgb$$\s*\d+\s*,\s*\d+\s*,\s*\d+\s*$$/g);
      if (rgbMatches) {
        // Convert rgb to hex
        rgbMatches.forEach(rgb => {
          const values = rgb.match(/\d+/g);
          if (values && values.length === 3) {
            const r = parseInt(values[0]);
            const g = parseInt(values[1]);
            const b = parseInt(values[2]);
            const hex = colorUtils.rgbToHex(r, g, b);
            colors.push(hex);
          }
        });
      }
      
      return colors;
    }

    // Update Algorithm stats
    function updateAlgorithmStats() {
      const totalSamples = appState.learningEngine.getTotalSamples();
      const likedColors = appState.learningEngine.getLikedColorsCount();
      const dislikedColors = appState.learningEngine.getDislikedColorsCount();
      const confidence = appState.learningEngine.getConfidenceScore();
      
      elements.totalSamples.textContent = totalSamples;
      elements.confidenceBar.style.width = `${confidence * 100}%`;
      elements.confidenceValue.textContent = `${Math.round(confidence * 100)}%`;
      
      elements.likedColorsBar.style.width = likedColors > 0 ? '100%' : '0%';
      elements.likedColorsCount.textContent = `${likedColors} colors liked`;
      
      elements.dislikedColorsBar.style.width = dislikedColors > 0 ? '100%' : '0%';
      elements.dislikedColorsCount.textContent = `${dislikedColors} colors disliked`;
    }

    // Train Algorithm
    async function trainAlgorithm() {
      if (appState.isTraining) return;
      
      appState.isTraining = true;
      appState.trainingProgress = 0;
      
      elements.trainAiBtn.innerHTML = `
        <div class="spinner"></div>
        Training 0%
      `;
      
      // Simulate training with progress updates
      for (let i = 0; i <= 10; i++) {
        await new Promise(resolve => setTimeout(resolve, 300));
        appState.trainingProgress = i * 10;
        
        elements.trainAiBtn.innerHTML = `
          <div class="spinner"></div>
          Training ${appState.trainingProgress}%
        `;
        
        if (i < 10) {
          // Generate and learn from random palettes during training
          const randomPalette = colorUtils.generateRandomPalette(5);
          appState.learningEngine.learnFromPalette(randomPalette, Math.random() > 0.5 ? 1 : -1);
        }
      }
      
      appState.isTraining = false;
      elements.trainAiBtn.innerHTML = `
        <svg class="icon" viewBox="0 0 24 24" width="16" height="16">
          <path d="M12 16l4-4h-3V3h-2v9H8l4 4zm9-13h-6v2h6v16H3V5h6V3H3a2 2 0 00-2 2v16a2 2 0 002 2h18a2 2 0 002-2V5a2 2 0 002-2z"></path>
        </svg>
        Train Algorithm
      `;
      
      updateAlgorithmStats();
      saveToLocalStorage();
      
      showToast('Algorithm Training Complete', 'Your algorithm has been trained with additional color data');
    }

    // Reset Algorithm
    function resetAlgorithm() {
      appState.learningEngine.reset();
      updateAlgorithmStats();
      saveToLocalStorage();
      
      showToast('Algorithm Reset', 'Your algorithm has been reset to default settings');
    }

    // Set color preference
    function setColorPreference(preference) {
      appState.colorPreference = preference;
      
      // Update UI
      elements.preferenceButtons.forEach(btn => {
        if (btn.dataset.preference === preference) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
      
      // Adjust the learning engine based on preference
      switch (preference) {
        case 'warm':
          appState.learningEngine.setColorBias({ r: 0.7, g: 0.5, b: 0.3 });
          break;
        case 'cool':
          appState.learningEngine.setColorBias({ r: 0.3, g: 0.5, b: 0.7 });
          break;
        case 'vibrant':
          appState.learningEngine.setSaturationPreference(0.8);
          break;
        case 'pastel':
          appState.learningEngine.setSaturationPreference(0.3);
          appState.learningEngine.setLightnessPreference(0.8);
          break;
        case 'dark':
          appState.learningEngine.setLightnessPreference(0.2);
          break;
        case 'balanced':
        default:
          appState.learningEngine.resetPreferences();
      }
      
      saveToLocalStorage();
      showToast('Color Preference Set', `Your algorithm will now favor ${preference} colors`);
    }

    // Generate Smart palette
    function generateSmartPalette() {
      const newPalette = appState.learningEngine.generatePalette(5, appState.creativity / 100);
      
      // Add current palette to history
      if (appState.currentPalette.length > 0) {
        appState.paletteHistory = [appState.currentPalette, ...appState.paletteHistory].slice(0, 5);
      }
      
      appState.currentPalette = newPalette;
      renderColorPalette();
      updateAnimatedBackground();
      saveToLocalStorage();
      
      showToast('Smart Palette Generated', `Created with ${appState.creativity}% creativity level`);
    }

    // Show toast notification
    function showToast(title, message) {
      const toast = document.createElement('div');
      toast.className = 'toast';
      toast.innerHTML = `
        <div class="toast-title">${title}</div>
        <div class="toast-message">${message}</div>
      `;
      
      elements.toastContainer.appendChild(toast);
      
      // Remove toast after 3 seconds
      setTimeout(() => {
        toast.remove();
      }, 3000);
    }

    // Initialize animated background
    function initAnimatedBackground() {
      const canvas = elements.backgroundCanvas;
      const ctx = canvas.getContext('2d');
      
      // Set canvas dimensions
      function updateCanvasSize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      
      updateCanvasSize();
      window.addEventListener('resize', updateCanvasSize);
      
      // Create particles
      const particles = [];
      const particleCount = 50;
      
      function createParticles() {
        particles.length = 0;
        
        // Use current palette or default colors
        const usableColors = appState.currentPalette.length > 0 
          ? appState.currentPalette 
          : ['#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6'];
        
        for (let i = 0; i < particleCount; i++) {
          const color = usableColors[Math.floor(Math.random() * usableColors.length)];
          const rgb = colorUtils.hexToRgb(color);
          
          particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            radius: Math.random() * 5 + 2,
            color: `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${Math.random() * 0.5 + 0.1})`,
            vx: Math.random() * 1 - 0.5,
            vy: Math.random() * 1 - 0.5,
            sinOffset: Math.random() * Math.PI * 2,
          });
        }
      }
      
      createParticles();
      
      // Animation function
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw gradient background
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        const usableColors = appState.currentPalette.length > 0 
          ? appState.currentPalette 
          : ['#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6'];
        
        usableColors.forEach((color, index) => {
          gradient.addColorStop(index / (usableColors.length - 1), color + '20'); // 20 is hex for 12% opacity
        });
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Update and draw particles
        particles.forEach(particle => {
          // Update position with a slight sine wave motion
          particle.x += particle.vx;
          particle.y += particle.vy + Math.sin(Date.now() * 0.001 + particle.sinOffset) * 0.5;
          
          // Bounce off edges
          if (particle.x < 0 || particle.x > canvas.width) particle.vx *= -1;
          if (particle.y < 0 || particle.y > canvas.height) particle.vy *= -1;
          
          // Draw particle
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
          ctx.fillStyle = particle.color;
          ctx.fill();
        });
        
        requestAnimationFrame(animate);
      }
      
      animate();
      
      // Function to update particles when palette changes
      window.updateAnimatedBackground = function() {
        createParticles();
      };
    }

    // Set up event listeners
    function setupEventListeners() {
      // Generate button
      elements.generateBtn.addEventListener('click', generateNewPalette);
      
      // History button
      elements.historyBtn.addEventListener('click', showHistory);
      
      // Replace the format dropdown event listeners with this:
      elements.formatBtn.addEventListener('click', cycleColorFormat);
      
      // Like button
      elements.likeBtn.addEventListener('click', likePalette);
      
      // Dislike button
      elements.dislikeBtn.addEventListener('click', dislikePalette);
      
      // Export button
      elements.exportBtn.addEventListener('click', showExport);
      
      // Import button
      elements.importBtn.addEventListener('click', showImport);
      
      // Generation mode select
      elements.generationMode.addEventListener('change', (e) => {
        appState.generationMode = e.target.value;
      });
      
      // Tabs
      elements.tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const tabName = tab.dataset.tab;
          
          // Update active tab
          elements.tabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          
          // Show corresponding content
          elements.tabContents.forEach(content => {
            if (content.id === `${tabName}-tab`) {
              content.classList.add('active');
            } else {
              content.classList.remove('active');
            }
          });
          
          appState.activeTab = tabName;
        });
      });
      
      // Close color info modal
      elements.closeColorInfo.addEventListener('click', () => {
        elements.colorInfoModal.classList.add('hidden');
      });
      
      // Copy color button in color info modal
      elements.copyColorBtn.addEventListener('click', () => {
        const color = appState.currentPalette[appState.selectedColorIndex];
        copyToClipboard(color);
      });
      
      // Close history modal
      elements.closeHistory.addEventListener('click', () => {
        elements.historyModal.classList.add('hidden');
      });
      
      // Close export modal
      elements.closeExport.addEventListener('click', () => {
        elements.exportModal.classList.add('hidden');
      });
      
      // Export tabs
      elements.exportTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          setActiveExportTab(tab.dataset.exportTab);
        });
      });
      
      // Download code button
      elements.downloadCodeBtn.addEventListener('click', downloadExportCode);
      
      // Copy code button
      elements.copyCodeBtn.addEventListener('click', () => {
        copyToClipboard(elements.exportCode.textContent);
        elements.copyCodeBtn.innerHTML = `
          <svg class="icon" viewBox="0 0 24 24" width="16" height="16">
            <path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z"></path>
          </svg>
          Copied!
        `;
        
        setTimeout(() => {
          elements.copyCodeBtn.innerHTML = `
            <svg class="icon" viewBox="0 0 24 24" width="16" height="16">
              <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path>
            </svg>
            Copy to Clipboard
          `;
        }, 2000);
      });
      
      // Close import modal
      elements.closeImport.addEventListener('click', () => {
        elements.importModal.classList.add('hidden');
      });
      
      // Import tabs
      elements.importTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          setActiveImportTab(tab.dataset.importTab);
        });
      });
      
      // Import colors button
      elements.importColorsBtn.addEventListener('click', importColors);
      
      // Train Algorithm button
      elements.trainAiBtn.addEventListener('click', trainAlgorithm);
      
      // Reset Algorithm button
      elements.resetAiBtn.addEventListener('click', resetAlgorithm);
      
      // Creativity slider
      elements.creativitySlider.addEventListener('input', (e) => {
        appState.creativity = e.target.value;
        elements.creativityValue.textContent = `${appState.creativity}%`;
      });
      
      // Color preference buttons
      elements.preferenceButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          setColorPreference(btn.dataset.preference);
        });
      });
      
      // Generate Smart palette button
      elements.generateAiBtn.addEventListener('click', generateSmartPalette);
      
      // Close modals when clicking outside
      elements.colorInfoModal.addEventListener('click', (e) => {
        if (e.target === elements.colorInfoModal) {
          elements.colorInfoModal.classList.add('hidden');
        }
      });
      
      elements.historyModal.addEventListener('click', (e) => {
        if (e.target === elements.historyModal) {
          elements.historyModal.classList.add('hidden');
        }
      });
      
      elements.exportModal.addEventListener('click', (e) => {
        if (e.target === elements.exportModal) {
          elements.exportModal.classList.add('hidden');
        }
      });
      
      elements.importModal.addEventListener('click', (e) => {
        if (e.target === elements.importModal) {
          elements.importModal.classList.add('hidden');
        }
      });
      
      // Escape key to close modals
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          elements.colorInfoModal.classList.add('hidden');
          elements.historyModal.classList.add('hidden');
          elements.exportModal.classList.add('hidden');
          elements.importModal.classList.add('hidden');
        }
      });

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        // Only respond to shortcuts when not in an input field
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        // Keyboard shortcut for format cycling
        if (e.key.toLowerCase() === 'f') {
          cycleColorFormat();
        }
        
        // Generate new palette with 'G' key
        if (e.key.toLowerCase() === 'g') {
          generateNewPalette();
        }
        
        // Like palette with 'L' key
        if (e.key.toLowerCase() === 'l') {
          likePalette();
        }
        
        // Dislike palette with 'D' key
        if (e.key.toLowerCase() === 'd') {
          dislikePalette();
        }
      });
    }

    // Initialize the app when the DOM is loaded
    document.addEventListener('DOMContentLoaded', initApp);
  </script>
</body>
</html>
